local helpers = require("tests.helpers")

describe("core", function()
  local core

  before_each(function()
    package.loaded["monava.core"] = nil
    core = require("monava.core")
  end)

  after_each(function()
    helpers.fs_rm()
  end)

  describe("detect_monorepo_type", function()
    it("should detect Lerna monorepos", function()
      local workspace = helpers.fs_create({
        ["lerna.json"] = '{"version": "0.0.0", "packages": ["packages/*"]}',
        ["package.json"] = '{"name": "root", "private": true}',
        ["packages/pkg1/package.json"] = '{"name": "pkg1"}',
        ["packages/pkg2/package.json"] = '{"name": "pkg2"}',
      })

      local monorepo_type = core.detect_monorepo_type(workspace)
      assert.are.equal("lerna", monorepo_type)
    end)

    it("should detect Nx monorepos", function()
      local workspace = helpers.fs_create({
        ["nx.json"] = '{"npmScope": "company"}',
        ["workspace.json"] = '{"projects": {"app1": "apps/app1"}}',
        ["package.json"] = '{"name": "nx-workspace"}',
        ["apps/app1/project.json"] = '{"name": "app1"}',
      })

      local monorepo_type = core.detect_monorepo_type(workspace)
      assert.are.equal("nx", monorepo_type)
    end)

    it("should detect Yarn workspaces", function()
      local workspace = helpers.fs_create({
        ["package.json"] = '{"name": "root", "workspaces": ["packages/*"]}',
        ["yarn.lock"] = "# yarn lockfile v1",
        ["packages/pkg1/package.json"] = '{"name": "@company/pkg1"}',
      })

      local monorepo_type = core.detect_monorepo_type(workspace)
      assert.are.equal("yarn_workspaces", monorepo_type)
    end)

    it("should detect npm workspaces", function()
      local workspace = helpers.fs_create({
        ["package.json"] = '{"name": "root", "workspaces": ["packages/*"]}',
        ["package-lock.json"] = '{"lockfileVersion": 2}',
        ["packages/pkg1/package.json"] = '{"name": "pkg1"}',
      })

      local monorepo_type = core.detect_monorepo_type(workspace)
      assert.are.equal("npm_workspaces", monorepo_type)
    end)

    it("should detect PNPM workspaces", function()
      local workspace = helpers.fs_create({
        ["pnpm-workspace.yaml"] = 'packages:\n  - "packages/*"\n  - "apps/*"',
        ["pnpm-lock.yaml"] = "lockfileVersion: '6.0'",
        ["packages/pkg1/package.json"] = '{"name": "@company/pkg1"}',
      })

      local monorepo_type = core.detect_monorepo_type(workspace)
      assert.are.equal("pnpm", monorepo_type)
    end)

    it("should detect Cargo workspaces", function()
      local workspace = helpers.fs_create({
        ["Cargo.toml"] = '[workspace]\nmembers = ["crates/*"]',
        ["Cargo.lock"] = "# This file is automatically generated",
        ["crates/lib1/Cargo.toml"] = '[package]\nname = "lib1"',
      })

      local monorepo_type = core.detect_monorepo_type(workspace)
      assert.are.equal("cargo_workspace", monorepo_type)
    end)

    it("should return nil for non-monorepo directories", function()
      local workspace = helpers.fs_create({
        ["package.json"] = '{"name": "single-project"}',
        ["src/index.js"] = 'console.log("hello");',
      })

      local monorepo_type = core.detect_monorepo_type(workspace)
      assert.is_nil(monorepo_type)
    end)

    it("should handle empty directories", function()
      local workspace = helpers.fs_create({})

      local monorepo_type = core.detect_monorepo_type(workspace)
      assert.is_nil(monorepo_type)
    end)
  end)

  describe("enumerate_packages", function()
    local test_workspace

    before_each(function()
      test_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "root", "workspaces": ["packages/*"]}',
        ["packages/ui/package.json"] = '{"name": "@company/ui", "version": "1.0.0"}',
        ["packages/utils/package.json"] = '{"name": "@company/utils", "version": "2.1.0"}',
        ["packages/api/package.json"] = '{"name": "@company/api", "version": "1.5.0"}',
        ["apps/web/package.json"] = '{"name": "web-app", "version": "0.1.0"}',
      })
    end)

    it("should enumerate all packages in a monorepo", function()
      local packages = core.enumerate_packages(test_workspace)

      assert.is.table(packages)
      assert.is_true(#packages >= 4)

      for _, pkg in ipairs(packages) do
        helpers.assert_has_keys(pkg, { "name", "path", "type" })
        assert.is.string(pkg.name)
        assert.is.string(pkg.path)
        assert.are.equal("javascript", pkg.type)
      end
    end)

    it("should include package metadata when requested", function()
      local packages = core.enumerate_packages(test_workspace, { include_metadata = true })

      for _, pkg in ipairs(packages) do
        if pkg.name == "@company/ui" then
          assert.are.equal("1.0.0", pkg.version)
          assert.is_false(pkg.private or false)
        end
      end
    end)

    it("should filter by package type", function()
      -- Add non-JS packages
      helpers.fs_create({
        ["rust-crate/Cargo.toml"] = '[package]\nname = "rust-crate"',
        ["go-module/go.mod"] = "module go-module",
      })

      local js_packages = core.enumerate_packages(test_workspace, { type = "javascript" })

      assert.is_true(#js_packages >= 4)

      for _, pkg in ipairs(js_packages) do
        assert.are.equal("javascript", pkg.type)
      end
    end)

    it("should respect package limits", function()
      local limited_packages = core.enumerate_packages(test_workspace, { limit = 2 })

      assert.is.table(limited_packages)
      assert.is_true(#limited_packages <= 2)
    end)

    it("should handle missing package files gracefully", function()
      helpers.fs_create({
        ["broken/package.json"] = "invalid json {",
        ["empty/package.json"] = "",
      })

      local packages = core.enumerate_packages(test_workspace)

      assert.is.table(packages)
      assert.is_true(#packages >= 4)
    end)
  end)

  describe("PNPM workspace support", function()
    local pnpm_workspace

    before_each(function()
      pnpm_workspace = helpers.fs_create({
        ["pnpm-workspace.yaml"] = 'packages:\n  - "packages/*"\n  - "apps/*"\n  - "!**/test/**"',
        ["pnpm-lock.yaml"] = "lockfileVersion: '6.0'",
        ["package.json"] = '{"name": "pnpm-monorepo", "private": true}',
        ["packages/ui/package.json"] = '{"name": "@company/ui", "version": "1.0.0", "description": "UI components"}',
        ["packages/utils/package.json"] = '{"name": "@company/utils", "version": "2.1.0", "private": true}',
        ["apps/web/package.json"] = '{"name": "web-app", "version": "0.1.0", "scripts": {"dev": "vite"}}',
        ["apps/api/package.json"] = '{"name": "api-server", "version": "1.2.0"}',
        ["packages/test/ignore-me/package.json"] = '{"name": "test-pkg"}', -- Should be excluded
      })
    end)

    it("should detect PNPM workspaces correctly", function()
      local monorepo_type = core.detect_monorepo_type(pnpm_workspace)
      assert.are.equal("pnpm", monorepo_type)
    end)

    it("should enumerate PNPM packages with glob patterns", function()
      local packages = core.enumerate_packages(pnpm_workspace, { include_metadata = true })

      assert.is.table(packages)
      assert.are.equal(4, #packages) -- Should exclude test package

      -- Check that we have the expected packages
      local package_names = {}
      for _, pkg in ipairs(packages) do
        table.insert(package_names, pkg.name)
      end

      assert.is_true(vim.tbl_contains(package_names, "@company/ui"))
      assert.is_true(vim.tbl_contains(package_names, "@company/utils"))
      assert.is_true(vim.tbl_contains(package_names, "web-app"))
      assert.is_true(vim.tbl_contains(package_names, "api-server"))
      assert.is_false(vim.tbl_contains(package_names, "test-pkg")) -- Should be excluded
    end)

    it("should handle PNPM package metadata correctly", function()
      local packages = core.enumerate_packages(pnpm_workspace, { include_metadata = true })

      for _, pkg in ipairs(packages) do
        if pkg.name == "@company/ui" then
          assert.are.equal("1.0.0", pkg.version)
          assert.are.equal("UI components", pkg.description)
          assert.is_false(pkg.private)
        elseif pkg.name == "@company/utils" then
          assert.are.equal("2.1.0", pkg.version)
          assert.is_true(pkg.private)
        elseif pkg.name == "web-app" then
          assert.is.table(pkg.scripts)
          assert.are.equal("vite", pkg.scripts.dev)
        end
      end
    end)

    it("should handle complex PNPM workspace patterns", function()
      local complex_workspace = helpers.fs_create({
        ["pnpm-workspace.yaml"] = 'packages:\n  - "libs/**"\n  - "services/*"\n  - "!**/dist"\n  - "!**/node_modules"',
        ["libs/core/package.json"] = '{"name": "@lib/core"}',
        ["libs/shared/utils/package.json"] = '{"name": "@lib/shared-utils"}',
        ["services/auth/package.json"] = '{"name": "auth-service"}',
        ["services/payment/package.json"] = '{"name": "payment-service"}',
        ["libs/core/dist/package.json"] = '{"name": "should-be-ignored"}', -- Should be excluded
      })

      local packages = core.enumerate_packages(complex_workspace)

      assert.is.table(packages)
      assert.are.equal(4, #packages)

      local package_names = {}
      for _, pkg in ipairs(packages) do
        table.insert(package_names, pkg.name)
      end

      assert.is_true(vim.tbl_contains(package_names, "@lib/core"))
      assert.is_true(vim.tbl_contains(package_names, "@lib/shared-utils"))
      assert.is_true(vim.tbl_contains(package_names, "auth-service"))
      assert.is_true(vim.tbl_contains(package_names, "payment-service"))
      assert.is_false(vim.tbl_contains(package_names, "should-be-ignored"))
    end)

    it("should handle malformed PNPM workspace files", function()
      local bad_workspace = helpers.fs_create({
        ["pnpm-workspace.yaml"] = "invalid: yaml: content: [",
        ["packages/pkg1/package.json"] = '{"name": "pkg1"}',
      })

      local packages = core.enumerate_packages(bad_workspace)
      assert.is.table(packages)
      assert.are.equal(0, #packages) -- Should return empty on parse error
    end)

    it("should handle missing pnpm-workspace.yaml gracefully", function()
      local no_workspace = helpers.fs_create({
        ["pnpm-lock.yaml"] = "lockfileVersion: '6.0'",
        ["packages/pkg1/package.json"] = '{"name": "pkg1"}',
      })

      local packages = core.enumerate_packages(no_workspace)
      assert.is.table(packages)
      assert.are.equal(0, #packages) -- Should return empty without workspace file
    end)

    describe("PNPM performance tests", function()
      it("should handle large workspaces efficiently", function()
        -- Create workspace with 50 packages to test performance optimizations
        local large_workspace_files = {
          ["pnpm-workspace.yaml"] = 'packages:\n  - "packages/*"\n  - "apps/*"',
          ["pnpm-lock.yaml"] = "lockfileVersion: '6.0'",
          ["package.json"] = '{"name": "large-pnpm-workspace", "private": true}',
        }

        -- Generate 50 packages across different directories
        for i = 1, 30 do
          large_workspace_files["packages/pkg" .. i .. "/package.json"] =
            string.format('{"name": "@test/pkg%d", "version": "1.0.%d"}', i, i)
        end
        for i = 1, 20 do
          large_workspace_files["apps/app" .. i .. "/package.json"] =
            string.format('{"name": "app%d", "version": "0.1.%d"}', i, i)
        end

        local large_workspace = helpers.fs_create(large_workspace_files)

        local start_time = vim.loop.hrtime()
        local packages = core.enumerate_packages(large_workspace, { include_metadata = true })
        local end_time = vim.loop.hrtime()

        assert.is.table(packages)
        assert.are.equal(50, #packages)

        -- Should complete within 2 seconds even for large workspaces
        local duration_ms = (end_time - start_time) / 1000000
        assert.is_true(
          duration_ms < 2000,
          string.format(
            "Large workspace enumeration took too long: %.2fms (expected < 2000ms)",
            duration_ms
          )
        )

        -- Verify all packages have proper metadata
        for _, pkg in ipairs(packages) do
          assert.is.string(pkg.name)
          assert.is.string(pkg.path)
          assert.is.string(pkg.version)
        end
      end)

      it("should handle deeply nested structures efficiently", function()
        -- Create workspace with deeply nested packages to test depth limiting
        local deep_workspace = helpers.fs_create({
          ["pnpm-workspace.yaml"] = 'packages:\n  - "libs/**"',
          ["libs/level1/level2/level3/level4/level5/package.json"] = '{"name": "@deep/nested"}',
          ["libs/level1/level2/level3/package.json"] = '{"name": "@deep/medium"}',
          ["libs/level1/package.json"] = '{"name": "@deep/shallow"}',
          -- Add some non-package directories at various levels
          ["libs/level1/level2/level3/level4/level5/level6/level7/file.txt"] = "deep file",
          ["libs/level1/level2/level3/level4/docs/README.md"] = "documentation",
        })

        local start_time = vim.loop.hrtime()
        local packages = core.enumerate_packages(deep_workspace)
        local end_time = vim.loop.hrtime()

        assert.is.table(packages)
        assert.are.equal(3, #packages) -- Should find all 3 packages

        -- Should complete quickly due to depth limiting
        local duration_ms = (end_time - start_time) / 1000000
        assert.is_true(
          duration_ms < 500,
          string.format("Deep nesting took too long: %.2fms (expected < 500ms)", duration_ms)
        )

        local package_names = {}
        for _, pkg in ipairs(packages) do
          table.insert(package_names, pkg.name)
        end

        assert.is_true(vim.tbl_contains(package_names, "@deep/nested"))
        assert.is_true(vim.tbl_contains(package_names, "@deep/medium"))
        assert.is_true(vim.tbl_contains(package_names, "@deep/shallow"))
      end)

      it("should handle complex exclusion patterns efficiently", function()
        -- Test performance with multiple exclusion patterns
        local workspace = helpers.fs_create({
          ["pnpm-workspace.yaml"] = 'packages:\n  - "packages/**"\n  - "!**/test/**"\n  - "!**/dist/**"\n  - "!**/node_modules/**"',
          -- Valid packages
          ["packages/core/package.json"] = '{"name": "@test/core"}',
          ["packages/ui/components/package.json"] = '{"name": "@test/ui-components"}',
          ["packages/utils/helpers/package.json"] = '{"name": "@test/helpers"}',
          -- Should be excluded
          ["packages/core/test/unit/package.json"] = '{"name": "should-be-excluded"}',
          ["packages/ui/dist/build/package.json"] = '{"name": "should-be-excluded-dist"}',
          ["packages/node_modules/dep/package.json"] = '{"name": "should-be-excluded-deps"}',
          ["packages/core/test/integration/package.json"] = '{"name": "should-be-excluded-integration"}',
        })

        local start_time = vim.loop.hrtime()
        local packages = core.enumerate_packages(workspace)
        local end_time = vim.loop.hrtime()

        assert.is.table(packages)
        assert.are.equal(3, #packages) -- Only the non-excluded packages

        -- Should complete quickly despite exclusion processing
        local duration_ms = (end_time - start_time) / 1000000
        assert.is_true(
          duration_ms < 1000,
          string.format("Complex exclusions took too long: %.2fms (expected < 1000ms)", duration_ms)
        )

        local package_names = {}
        for _, pkg in ipairs(packages) do
          table.insert(package_names, pkg.name)
        end

        assert.is_true(vim.tbl_contains(package_names, "@test/core"))
        assert.is_true(vim.tbl_contains(package_names, "@test/ui-components"))
        assert.is_true(vim.tbl_contains(package_names, "@test/helpers"))
        assert.is_false(vim.tbl_contains(package_names, "should-be-excluded"))
        assert.is_false(vim.tbl_contains(package_names, "should-be-excluded-dist"))
        assert.is_false(vim.tbl_contains(package_names, "should-be-excluded-deps"))
      end)

      it("should limit scanning depth for recursive patterns", function()
        -- Create a workspace with very deep directory structure
        local files = {
          ["pnpm-workspace.yaml"] = 'packages:\n  - "deep/**"',
        }

        -- Create 15 levels deep (should hit depth limit of 10)
        local path_parts = { "deep" }
        for i = 1, 15 do
          table.insert(path_parts, "level" .. i)
          local current_path = table.concat(path_parts, "/")
          files[current_path .. "/package.json"] = string.format('{"name": "@deep/level%d"}', i)
        end

        local deep_workspace = helpers.fs_create(files)

        local start_time = vim.loop.hrtime()
        local packages = core.enumerate_packages(deep_workspace)
        local end_time = vim.loop.hrtime()

        assert.is.table(packages)
        -- Should find packages up to depth limit (around 10 levels)
        assert.is_true(#packages >= 10, "Should find at least 10 packages")
        assert.is_true(#packages <= 15, "Should not exceed total packages")

        -- Should complete quickly due to depth limiting
        local duration_ms = (end_time - start_time) / 1000000
        assert.is_true(
          duration_ms < 1000,
          string.format(
            "Deep recursive scan took too long: %.2fms (expected < 1000ms)",
            duration_ms
          )
        )
      end)
    end)

    describe("PNPM integration and edge cases", function()
      it("should handle mixed package manager scenarios", function()
        -- Test workspace with both PNPM and NPM configurations
        local mixed_workspace = helpers.fs_create({
          ["pnpm-workspace.yaml"] = 'packages:\n  - "pnpm-packages/*"',
          ["package.json"] = '{"name": "mixed-workspace", "workspaces": ["npm-packages/*"], "private": true}',
          ["pnpm-lock.yaml"] = "lockfileVersion: '6.0'",
          ["package-lock.json"] = '{"lockfileVersion": 2}',
          -- PNPM-managed packages
          ["pnpm-packages/ui/package.json"] = '{"name": "@pnpm/ui"}',
          ["pnpm-packages/utils/package.json"] = '{"name": "@pnpm/utils"}',
          -- NPM-managed packages (should not be detected when PNPM is the primary)
          ["npm-packages/legacy/package.json"] = '{"name": "@npm/legacy"}',
        })

        -- Should detect as PNPM workspace (PNPM takes precedence)
        local monorepo_type = core.detect_monorepo_type(mixed_workspace)
        assert.are.equal("pnpm", monorepo_type)

        -- Should only find PNPM-managed packages
        local packages = core.enumerate_packages(mixed_workspace)
        assert.is.table(packages)
        assert.are.equal(2, #packages)

        local package_names = {}
        for _, pkg in ipairs(packages) do
          table.insert(package_names, pkg.name)
        end

        assert.is_true(vim.tbl_contains(package_names, "@pnpm/ui"))
        assert.is_true(vim.tbl_contains(package_names, "@pnpm/utils"))
        assert.is_false(vim.tbl_contains(package_names, "@npm/legacy"))
      end)

      it("should handle workspaces with non-JavaScript packages", function()
        local polyglot_workspace = helpers.fs_create({
          ["pnpm-workspace.yaml"] = 'packages:\n  - "packages/*"\n  - "services/*"',
          -- JavaScript packages
          ["packages/web/package.json"] = '{"name": "@app/web", "type": "module"}',
          ["packages/api/package.json"] = '{"name": "@app/api", "scripts": {"start": "node index.js"}}',
          -- Mixed language directory with package.json (should be included)
          ["services/rust-service/package.json"] = '{"name": "rust-service", "scripts": {"build": "cargo build"}}',
          -- Pure non-JS files (no package.json, should be ignored)
          ["services/go-service/go.mod"] = "module go-service",
          ["services/python-service/pyproject.toml"] = "[tool.poetry]",
        })

        local packages = core.enumerate_packages(polyglot_workspace)
        assert.is.table(packages)
        assert.are.equal(3, #packages) -- Only packages with package.json

        local package_names = {}
        for _, pkg in ipairs(packages) do
          table.insert(package_names, pkg.name)
        end

        assert.is_true(vim.tbl_contains(package_names, "@app/web"))
        assert.is_true(vim.tbl_contains(package_names, "@app/api"))
        assert.is_true(vim.tbl_contains(package_names, "rust-service"))
      end)

      it("should handle workspace patterns with special characters", function()
        local special_workspace = helpers.fs_create({
          ["pnpm-workspace.yaml"] = 'packages:\n  - "packages-*/*"\n  - "apps.*/client*"',
          -- Packages matching patterns with special characters
          ["packages-v1/core/package.json"] = '{"name": "@v1/core"}',
          ["packages-v2/utils/package.json"] = '{"name": "@v2/utils"}',
          ["apps.web/client-app/package.json"] = '{"name": "client-app"}',
          ["apps.mobile/client-native/package.json"] = '{"name": "client-native"}',
          -- Should not match
          ["packages/regular/package.json"] = '{"name": "should-not-match"}',
          ["apps/server/package.json"] = '{"name": "should-not-match-2"}',
        })

        local packages = core.enumerate_packages(special_workspace)
        assert.is.table(packages)
        assert.are.equal(4, #packages)

        local package_names = {}
        for _, pkg in ipairs(packages) do
          table.insert(package_names, pkg.name)
        end

        assert.is_true(vim.tbl_contains(package_names, "@v1/core"))
        assert.is_true(vim.tbl_contains(package_names, "@v2/utils"))
        assert.is_true(vim.tbl_contains(package_names, "client-app"))
        assert.is_true(vim.tbl_contains(package_names, "client-native"))
        assert.is_false(vim.tbl_contains(package_names, "should-not-match"))
        assert.is_false(vim.tbl_contains(package_names, "should-not-match-2"))
      end)

      it("should handle workspace with empty directories and broken packages", function()
        local broken_workspace = helpers.fs_create({
          ["pnpm-workspace.yaml"] = 'packages:\n  - "packages/*"',
          -- Valid package
          ["packages/valid/package.json"] = '{"name": "@test/valid", "version": "1.0.0"}',
          -- Empty directory (no package.json)
          ["packages/empty/README.md"] = "Empty package directory",
          -- Broken package.json (malformed JSON)
          ["packages/broken/package.json"] = '{"name": "@test/broken", "version":',
          -- Package without name
          ["packages/no-name/package.json"] = '{"version": "1.0.0", "description": "Missing name"}',
          -- Valid package with minimal info
          ["packages/minimal/package.json"] = '{"name": "@test/minimal"}',
        })

        local packages = core.enumerate_packages(broken_workspace, { include_metadata = true })
        assert.is.table(packages)

        -- Should only include valid packages (those with parseable JSON and name field)
        local valid_count = 0
        local package_names = {}
        for _, pkg in ipairs(packages) do
          valid_count = valid_count + 1
          table.insert(package_names, pkg.name)
          assert.is.string(pkg.name)
          assert.is.string(pkg.path)
        end

        assert.are.equal(2, valid_count) -- only 'valid' and 'minimal'
        assert.is_true(vim.tbl_contains(package_names, "@test/valid"))
        assert.is_true(vim.tbl_contains(package_names, "@test/minimal"))
        assert.is_false(vim.tbl_contains(package_names, "@test/broken"))
        assert.is_false(vim.tbl_contains(package_names, ""))
      end)

      it("should handle workspace with different YAML formatting", function()
        -- Test various YAML formatting styles that should all work
        local yaml_variations = {
          -- Standard format
          {
            yaml = 'packages:\n  - "packages/*"',
            expected_packages = { "packages/*" },
          },
          -- Inline array format
          {
            yaml = 'packages: ["packages/*", "apps/*"]',
            expected_packages = { "packages/*", "apps/*" },
          },
          -- Mixed quotes and no quotes
          {
            yaml = "packages:\n  - packages/*\n  - 'apps/*'\n  - \"libs/*\"",
            expected_packages = { "packages/*", "apps/*", "libs/*" },
          },
          -- With comments and extra whitespace
          {
            yaml = "# PNPM workspace\npackages: # Package patterns\n  - packages/*  # Core packages\n  # Additional patterns\n  - apps/* # Applications",
            expected_packages = { "packages/*", "apps/*" },
          },
        }

        for i, variation in ipairs(yaml_variations) do
          local workspace = helpers.fs_create({
            ["pnpm-workspace.yaml"] = variation.yaml,
            ["packages/test/package.json"] = '{"name": "@test/pkg"}',
            ["apps/test/package.json"] = '{"name": "@test/app"}',
            ["libs/test/package.json"] = '{"name": "@test/lib"}',
          })

          local packages = core.enumerate_packages(workspace)
          assert.is.table(packages, "Variation " .. i .. " should return table")
          assert.is_true(
            #packages >= 1,
            "Variation " .. i .. " should find at least 1 package, got " .. #packages
          )

          helpers.fs_rm() -- Clean up for next iteration
        end
      end)

      it("should handle concurrent package enumeration gracefully", function()
        -- Test that multiple simultaneous enumerations don't interfere
        local workspace = helpers.fs_create({
          ["pnpm-workspace.yaml"] = 'packages:\n  - "packages/*"',
          ["packages/pkg1/package.json"] = '{"name": "@test/pkg1"}',
          ["packages/pkg2/package.json"] = '{"name": "@test/pkg2"}',
          ["packages/pkg3/package.json"] = '{"name": "@test/pkg3"}',
        })

        -- Simulate concurrent enumerations (though Lua is single-threaded,
        -- this tests that there are no shared state issues)
        local results = {}
        for i = 1, 3 do
          local packages = core.enumerate_packages(workspace, { include_metadata = true })
          table.insert(results, packages)
        end

        -- All results should be identical
        for i, result in ipairs(results) do
          assert.is.table(result, "Result " .. i .. " should be table")
          assert.are.equal(3, #result, "Result " .. i .. " should have 3 packages")

          local names = {}
          for _, pkg in ipairs(result) do
            table.insert(names, pkg.name)
          end

          assert.is_true(vim.tbl_contains(names, "@test/pkg1"))
          assert.is_true(vim.tbl_contains(names, "@test/pkg2"))
          assert.is_true(vim.tbl_contains(names, "@test/pkg3"))
        end
      end)
    end)
  end)

  describe("get_current_package", function()
    local mock_workspace

    before_each(function()
      mock_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "root"}',
        ["packages/ui/package.json"] = '{"name": "@company/ui"}',
        ["packages/ui/src/Button.tsx"] = "export const Button = () => {};",
        ["packages/api/package.json"] = '{"name": "@company/api"}',
        ["packages/api/routes/users.js"] = "module.exports = router;",
      })
    end)

    it("should detect current package from file path", function()
      local ui_file = helpers.path("packages/ui/src/Button.tsx")
      local current_pkg = core.get_current_package(ui_file, mock_workspace)

      assert.is.table(current_pkg)
      assert.are.equal("@company/ui", current_pkg.name)
      assert.is_true(current_pkg.path:match("packages/ui"))
    end)

    it("should return nil for root-level files", function()
      local root_file = helpers.path("package.json")
      local current_pkg = core.get_current_package(root_file, mock_workspace)

      assert.is_nil(current_pkg)
    end)

    it("should handle files outside workspace", function()
      local outside_file = "/tmp/other/file.js"
      local current_pkg = core.get_current_package(outside_file, mock_workspace)

      assert.is_nil(current_pkg)
    end)
  end)

  describe("analyze_monorepo", function()
    local complex_monorepo

    before_each(function()
      complex_monorepo = helpers.fs_create({
        ["package.json"] = '{"name": "monorepo-root", "workspaces": ["packages/*"]}',
        ["lerna.json"] = '{"version": "independent"}',
        ["packages/ui/package.json"] = '{"name": "@company/ui"}',
        ["packages/api/package.json"] = '{"name": "@company/api"}',
        ["rust-services/auth/Cargo.toml"] = '[package]\nname = "auth-service"',
        ["go-tools/cli/go.mod"] = "module company.com/cli",
      })
    end)

    it("should analyze monorepo structure", function()
      local analysis = core.analyze_monorepo(complex_monorepo)

      assert.is.table(analysis)
      helpers.assert_has_keys(analysis, {
        "type",
        "packages",
        "languages",
        "tools",
        "stats",
      })

      assert.are.equal("lerna", analysis.type)
      assert.is.table(analysis.packages)
      assert.is.table(analysis.languages)
      assert.is.table(analysis.stats)
    end)

    it("should detect multiple languages", function()
      local analysis = core.analyze_monorepo(complex_monorepo)

      local languages = analysis.languages
      assert.is_true(languages.javascript > 0)
      assert.is_true(languages.rust > 0)
      assert.is_true(languages.go > 0)
    end)

    it("should provide package statistics", function()
      local analysis = core.analyze_monorepo(complex_monorepo)

      local stats = analysis.stats
      helpers.assert_has_keys(stats, {
        "total_packages",
        "by_language",
        "by_type",
      })

      assert.is.number(stats.total_packages)
      assert.is_true(stats.total_packages >= 4)
      assert.is.table(stats.by_language)
      assert.is.table(stats.by_type)
    end)
  end)

  describe("performance", function()
    it("should handle large workspaces efficiently", function()
      local large_workspace = {}
      large_workspace["package.json"] = '{"name": "large", "workspaces": ["packages/*"]}'

      for i = 1, 50 do
        large_workspace["packages/pkg" .. i .. "/package.json"] = '{"name": "pkg' .. i .. '"}'
      end

      local workspace = helpers.fs_create(large_workspace)

      local start_time = vim.loop.hrtime()
      local packages = core.enumerate_packages(workspace)
      local end_time = vim.loop.hrtime()

      assert.is.table(packages)
      assert.is_true(#packages >= 50)

      local duration_ms = (end_time - start_time) / 1000000
      assert.is_true(
        duration_ms < 1000,
        "Large workspace enumeration took too long: " .. duration_ms .. "ms"
      )
    end)

    it("should cache detection results", function()
      local workspace = helpers.fs_create({
        ["package.json"] = '{"name": "root", "workspaces": ["packages/*"]}',
        ["packages/pkg1/package.json"] = '{"name": "pkg1"}',
      })

      local start_time = vim.loop.hrtime()
      local type1 = core.detect_monorepo_type(workspace)
      local end_time = vim.loop.hrtime()
      local first_duration = end_time - start_time

      start_time = vim.loop.hrtime()
      local type2 = core.detect_monorepo_type(workspace)
      end_time = vim.loop.hrtime()
      local second_duration = end_time - start_time

      assert.are.equal(type1, type2)
      assert.is_true(second_duration < first_duration / 2)
    end)
  end)

  describe("NPM Workspaces comprehensive support", function()
    local workspace_path

    before_each(function()
      workspace_path = helpers.fs_create({
        ["package.json"] = '{"name": "npm-monorepo", "private": true, "workspaces": ["packages/*", "apps/*"]}',
        ["package-lock.json"] = '{"lockfileVersion": 3, "requires": true}',
        ["packages/ui/package.json"] = '{"name": "@company/ui", "version": "1.0.0", "description": "UI components"}',
        ["packages/utils/package.json"] = '{"name": "@company/utils", "version": "2.1.0", "private": true}',
        ["apps/web/package.json"] = '{"name": "web-app", "version": "0.1.0", "scripts": {"dev": "vite"}}',
        ["apps/api/package.json"] = '{"name": "api-server", "version": "1.2.0"}',
      })
    end)

    it("should detect NPM workspaces correctly", function()
      local monorepo_type = core.detect_monorepo_type(workspace_path)
      assert.are.equal("npm_workspaces", monorepo_type, "Should detect NPM workspace type")
    end)

    it("should enumerate NPM packages with multiple patterns", function()
      local packages = core.enumerate_packages(workspace_path, { include_metadata = true })

      assert.is.table(packages)
      assert.are.equal(4, #packages)

      local package_names = {}
      for _, pkg in ipairs(packages) do
        table.insert(package_names, pkg.name)
      end

      assert.is_true(vim.tbl_contains(package_names, "@company/ui"))
      assert.is_true(vim.tbl_contains(package_names, "@company/utils"))
      assert.is_true(vim.tbl_contains(package_names, "web-app"))
      assert.is_true(vim.tbl_contains(package_names, "api-server"))
    end)

    it("should handle NPM package metadata correctly", function()
      local packages = core.enumerate_packages(workspace_path, { include_metadata = true })

      for _, pkg in ipairs(packages) do
        if pkg.name == "@company/ui" then
          assert.are.equal("1.0.0", pkg.version)
          assert.are.equal("UI components", pkg.description)
          assert.is_false(pkg.private or false)
        elseif pkg.name == "@company/utils" then
          assert.are.equal("2.1.0", pkg.version)
          assert.is_true(pkg.private)
        end
      end
    end)

    it("should handle NPM workspaces object format", function()
      local object_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "npm-obj", "workspaces": {"packages": ["libs/*"]}}',
        ["package-lock.json"] = '{"lockfileVersion": 2}',
        ["libs/core/package.json"] = '{"name": "@lib/core"}',
        ["libs/utils/package.json"] = '{"name": "@lib/utils"}',
      })

      local monorepo_type = core.detect_monorepo_type(object_workspace)
      assert.are.equal("npm_workspaces", monorepo_type)

      local packages = core.enumerate_packages(object_workspace)
      assert.is.table(packages)
      assert.are.equal(2, #packages)
    end)

    it("should handle workspace without lock file", function()
      local no_lock_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "no-lock", "workspaces": ["packages/*"]}',
        ["packages/test/package.json"] = '{"name": "test-pkg"}',
      })

      local monorepo_type = core.detect_monorepo_type(no_lock_workspace)
      assert.are.equal("npm_workspaces", monorepo_type)
    end)

    it("should handle large NPM workspaces efficiently", function()
      local large_workspace = helpers.create_npm_workspace(40)

      local start_time = vim.loop.hrtime()
      local packages = core.enumerate_packages(large_workspace)
      local end_time = vim.loop.hrtime()
      local duration_ms = (end_time - start_time) / 1000000

      assert.is.table(packages)
      assert.are.equal(40, #packages, "Should find all 40 packages in large NPM workspace")

      -- Log performance for monitoring without hard assertions
      if duration_ms > 500 then
        vim.notify(
          "[monava test] NPM workspace enumeration slow: " .. duration_ms .. "ms",
          vim.log.levels.WARN
        )
      end
    end)

    it("should handle malformed NPM package.json gracefully", function()
      local bad_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "bad", "workspaces": ["packages/*"]}',
        ["package-lock.json"] = '{"lockfileVersion": 2}',
        ["packages/good/package.json"] = '{"name": "@test/good"}',
        ["packages/bad/package.json"] = '{"name": "@test/bad", "version":',
      })

      local packages = core.enumerate_packages(bad_workspace)
      assert.is.table(packages)
      assert.are.equal(1, #packages) -- Only good package should be found
      assert.are.equal("@test/good", packages[1].name)
    end)

    it("should handle nested directory structures", function()
      local nested_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "nested", "workspaces": ["libs/*", "services/*"]}',
        ["package-lock.json"] = '{"lockfileVersion": 2}',
        ["libs/ui/package.json"] = '{"name": "@lib/ui"}',
        ["libs/shared/package.json"] = '{"name": "@lib/shared"}',
        ["services/auth/package.json"] = '{"name": "auth-service"}',
        ["services/payment/package.json"] = '{"name": "payment-service"}',
      })

      local packages = core.enumerate_packages(nested_workspace)
      assert.is.table(packages)
      assert.are.equal(4, #packages)

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end

      assert.is_true(vim.tbl_contains(names, "@lib/ui"))
      assert.is_true(vim.tbl_contains(names, "auth-service"))
    end)

    it("should handle unicode package names", function()
      local unicode_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "unicode-test", "workspaces": ["packages/*"]}',
        ["package-lock.json"] = '{"lockfileVersion": 2}',
        ["packages/测试包/package.json"] = '{"name": "测试-package"}',
        ["packages/español/package.json"] = '{"name": "@español/paquete"}',
        ["packages/日本語/package.json"] = '{"name": "日本語-パッケージ"}',
      })

      local packages = core.enumerate_packages(unicode_workspace)
      assert.is.table(packages)
      assert.are.equal(3, #packages, "Should find all unicode packages")

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end

      assert.is_true(vim.tbl_contains(names, "测试-package"))
      assert.is_true(vim.tbl_contains(names, "@español/paquete"))
      assert.is_true(vim.tbl_contains(names, "日本語-パッケージ"))
    end)

    it("should handle permission errors gracefully", function()
      local workspace = helpers.fs_create({
        ["package.json"] = '{"name": "permission-test", "workspaces": ["packages/*"]}',
        ["package-lock.json"] = '{"lockfileVersion": 2}',
        ["packages/accessible/package.json"] = '{"name": "accessible-pkg"}',
        ["packages/restricted/package.json"] = '{"name": "restricted-pkg"}',
      })

      -- Simulate restricted directory by creating a file instead of directory at expected path
      -- This is a portable way to test permission-like errors
      helpers.create_test_file(workspace, "packages/restricted/deeply", "not-a-directory")

      local packages = core.enumerate_packages(workspace)
      assert.is.table(packages)
      -- Should continue enumeration despite permission issues
      assert.is_true(#packages >= 1, "Should find at least accessible packages")

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end
      assert.is_true(vim.tbl_contains(names, "accessible-pkg"))
    end)
  end)

  describe("Yarn Workspaces comprehensive support", function()
    local workspace_path

    before_each(function()
      workspace_path = helpers.fs_create({
        ["package.json"] = '{"name": "yarn-monorepo", "private": true, "workspaces": ["packages/*", "apps/*"]}',
        ["yarn.lock"] = "# yarn lockfile v1\n\n",
        ["packages/ui/package.json"] = '{"name": "@company/ui", "version": "1.0.0"}',
        ["packages/utils/package.json"] = '{"name": "@company/utils", "version": "2.1.0"}',
        ["apps/web/package.json"] = '{"name": "web-app", "version": "0.1.0"}',
      })
    end)

    it("should detect Yarn workspaces correctly", function()
      local monorepo_type = core.detect_monorepo_type(workspace_path)
      assert.are.equal("yarn_workspaces", monorepo_type, "Should detect Yarn workspace type")
    end)

    it("should enumerate Yarn packages with glob patterns", function()
      local packages = core.enumerate_packages(workspace_path, { include_metadata = true })

      assert.is.table(packages)
      assert.are.equal(3, #packages)

      local package_names = {}
      for _, pkg in ipairs(packages) do
        table.insert(package_names, pkg.name)
      end

      assert.is_true(vim.tbl_contains(package_names, "@company/ui"))
      assert.is_true(vim.tbl_contains(package_names, "@company/utils"))
      assert.is_true(vim.tbl_contains(package_names, "web-app"))
    end)

    it("should handle Yarn v2+ Berry configuration", function()
      local berry_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "yarn-berry", "workspaces": ["packages/*"]}',
        [".yarnrc.yml"] = "nodeLinker: pnp\nnmHoistingLimits: workspaces\n",
        ["yarn.lock"] = '# This file is generated by running "yarn install" inside your project.\n__metadata:\n  version: 6\n',
        ["packages/core/package.json"] = '{"name": "@berry/core"}',
        ["packages/ui/package.json"] = '{"name": "@berry/ui"}',
      })

      local monorepo_type = core.detect_monorepo_type(berry_workspace)
      assert.are.equal("yarn_workspaces", monorepo_type)

      local packages = core.enumerate_packages(berry_workspace)
      assert.is.table(packages)
      assert.are.equal(2, #packages)
    end)

    it("should handle Yarn nohoist patterns", function()
      local nohoist_workspace = helpers.fs_create({
        ["package.json"] = [[{
          "name": "yarn-nohoist",
          "private": true,
          "workspaces": {
            "packages": ["packages/*"],
            "nohoist": ["**/react-native", "**/react-native/**"]
          }
        }]],
        ["yarn.lock"] = "# yarn lockfile v1\n",
        ["packages/mobile/package.json"] = '{"name": "mobile-app", "dependencies": {"react-native": "0.72.0"}}',
        ["packages/web/package.json"] = '{"name": "web-app"}',
      })

      local monorepo_type = core.detect_monorepo_type(nohoist_workspace)
      assert.are.equal("yarn_workspaces", monorepo_type)

      local packages = core.enumerate_packages(nohoist_workspace)
      assert.is.table(packages)
      assert.are.equal(2, #packages)
    end)

    it("should handle Yarn workspace protocols", function()
      local protocol_workspace = helpers.fs_create({
        ["package.json"] = '{"name": "yarn-protocols", "workspaces": ["packages/*"]}',
        ["yarn.lock"] = "# yarn lockfile v1\n",
        ["packages/ui/package.json"] = '{"name": "@pkg/ui", "dependencies": {"@pkg/utils": "workspace:*"}}',
        ["packages/utils/package.json"] = '{"name": "@pkg/utils", "version": "1.0.0"}',
      })

      local packages = core.enumerate_packages(protocol_workspace, { include_metadata = true })
      assert.is.table(packages)
      assert.are.equal(2, #packages)

      -- Should still discover packages despite workspace protocol dependencies
      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end
      assert.is_true(vim.tbl_contains(names, "@pkg/ui"))
      assert.is_true(vim.tbl_contains(names, "@pkg/utils"))
    end)

    it("should handle large Yarn workspaces with performance", function()
      local large_workspace = helpers.create_yarn_workspace(35, { pattern = "libs/*" })

      local start_time = vim.loop.hrtime()
      local packages = core.enumerate_packages(large_workspace)
      local end_time = vim.loop.hrtime()
      local duration_ms = (end_time - start_time) / 1000000

      assert.is.table(packages)
      assert.are.equal(35, #packages, "Should find all 35 packages in large Yarn workspace")

      -- Log performance for monitoring without hard assertions
      if duration_ms > 500 then
        vim.notify(
          "[monava test] Yarn workspace enumeration slow: " .. duration_ms .. "ms",
          vim.log.levels.WARN
        )
      end
    end)

    it("should handle very large package.json files", function()
      -- Test handling of unusually large package.json files
      local large_package_json = '{"name": "large-package", "dependencies": {'
      for i = 1, 1000 do
        large_package_json = large_package_json .. string.format('"dep%d": "^1.0.0"', i)
        if i < 1000 then
          large_package_json = large_package_json .. ", "
        end
      end
      large_package_json = large_package_json .. "}}"

      local workspace = helpers.fs_create({
        ["package.json"] = '{"name": "test-workspace", "workspaces": ["packages/*"], "private": true}',
        ["yarn.lock"] = "# yarn lockfile v1\n",
        ["packages/normal/package.json"] = '{"name": "normal-pkg"}',
        ["packages/large/package.json"] = large_package_json,
      })

      local packages = core.enumerate_packages(workspace)
      assert.is.table(packages)
      assert.are.equal(2, #packages, "Should handle large package.json files")

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end
      assert.is_true(vim.tbl_contains(names, "normal-pkg"))
      assert.is_true(vim.tbl_contains(names, "large-package"))
    end)
  end)

  describe("Nx Monorepos comprehensive support", function()
    local nx_workspace

    before_each(function()
      nx_workspace = helpers.fs_create({
        ["nx.json"] = [[{
          "targetDefaults": {
            "build": {
              "executor": "@nx/js:tsc"
            }
          },
          "plugins": ["@nx/js"],
          "parallel": 3
        }]],
        ["apps/web/project.json"] = [[{
          "name": "web",
          "root": "apps/web",
          "sourceRoot": "apps/web/src",
          "targets": {
            "build": {
              "executor": "@nx/js:tsc"
            }
          }
        }]],
        ["apps/api/project.json"] = [[{
          "name": "api",
          "root": "apps/api",
          "targets": {
            "build": {
              "executor": "@nx/node:build"
            }
          }
        }]],
        ["libs/ui/project.json"] = [[{
          "name": "ui",
          "root": "libs/ui",
          "sourceRoot": "libs/ui/src",
          "tags": ["type:ui"]
        }]],
        ["libs/shared/package.json"] = '{"name": "@nx/shared"}',
      })
    end)

    it("should detect Nx workspaces correctly", function()
      local monorepo_type = core.detect_monorepo_type(nx_workspace)
      assert.are.equal("nx", monorepo_type)
    end)

    it("should enumerate Nx projects from multiple directories", function()
      local packages = core.enumerate_packages(nx_workspace)

      assert.is.table(packages)
      assert.are.equal(4, #packages) -- 2 apps + 2 libs

      local project_names = {}
      for _, pkg in ipairs(packages) do
        table.insert(project_names, pkg.name)
      end

      -- Should find both project.json and package.json projects
      assert.is_true(vim.tbl_contains(project_names, "web"))
      assert.is_true(vim.tbl_contains(project_names, "api"))
      assert.is_true(vim.tbl_contains(project_names, "ui"))
      assert.is_true(vim.tbl_contains(project_names, "@nx/shared"))
    end)

    it("should handle Nx with mixed project types", function()
      local mixed_workspace = helpers.fs_create({
        ["nx.json"] = '{"plugins": ["@nx/js", "@nx/react"]}',
        ["apps/react-app/project.json"] = '{"name": "react-app", "root": "apps/react-app"}',
        ["apps/node-api/package.json"] = '{"name": "node-api"}',
        ["libs/react-ui/project.json"] = '{"name": "react-ui", "root": "libs/react-ui"}',
        ["libs/node-utils/package.json"] = '{"name": "node-utils"}',
        ["packages/shared/package.json"] = '{"name": "@shared/common"}',
      })

      local packages = core.enumerate_packages(mixed_workspace)
      assert.is.table(packages)
      assert.are.equal(5, #packages)

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end

      assert.is_true(vim.tbl_contains(names, "react-app"))
      assert.is_true(vim.tbl_contains(names, "node-api"))
      assert.is_true(vim.tbl_contains(names, "@shared/common"))
    end)

    it("should handle Nx workspace with package.json workspaces", function()
      local hybrid_workspace = helpers.fs_create({
        ["nx.json"] = '{"plugins": ["@nx/js"]}',
        ["package.json"] = '{"workspaces": ["tools/*"]}',
        ["apps/web/project.json"] = '{"name": "web-app"}',
        ["libs/ui/project.json"] = '{"name": "ui-lib"}',
        ["tools/build/package.json"] = '{"name": "build-tool"}',
        ["tools/deploy/package.json"] = '{"name": "deploy-tool"}',
      })

      local monorepo_type = core.detect_monorepo_type(hybrid_workspace)
      assert.are.equal("nx", monorepo_type) -- Nx takes precedence

      local packages = core.enumerate_packages(hybrid_workspace)
      assert.is.table(packages)
      assert.are.equal(4, #packages) -- Should find both Nx projects and npm workspace packages
    end)

    it("should handle large Nx workspaces efficiently", function()
      local large_workspace = helpers.create_nx_workspace(30, { parallel = 4 })

      local start_time = vim.loop.hrtime()
      local packages = core.enumerate_packages(large_workspace)
      local end_time = vim.loop.hrtime()
      local duration_ms = (end_time - start_time) / 1000000

      assert.is.table(packages)
      assert.are.equal(30, #packages, "Should find all 30 projects in large Nx workspace")

      -- Log performance for monitoring without hard assertions
      if duration_ms > 1000 then
        vim.notify(
          "[monava test] Nx workspace enumeration slow: " .. duration_ms .. "ms",
          vim.log.levels.WARN
        )
      end
    end)

    it("should handle malformed Nx configuration gracefully", function()
      local bad_workspace = helpers.fs_create({
        ["nx.json"] = '{"plugins": [',
        ["apps/good/project.json"] = '{"name": "good-app"}',
        ["apps/bad/project.json"] = '{"name": "bad-app", "root":',
        ["libs/good/package.json"] = '{"name": "good-lib"}',
      })

      local packages = core.enumerate_packages(bad_workspace)
      assert.is.table(packages)
      assert.are.equal(2, #packages) -- Should find good projects despite bad configs

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end
      assert.is_true(vim.tbl_contains(names, "good-app"))
      assert.is_true(vim.tbl_contains(names, "good-lib"))
    end)
  end)

  describe("Cargo Workspaces comprehensive support", function()
    local cargo_workspace

    before_each(function()
      cargo_workspace = helpers.fs_create({
        ["Cargo.toml"] = [[
[workspace]
members = [
    "crates/core",
    "crates/utils",
    "bin/cli",
]

[workspace.dependencies]
serde = "1.0"
tokio = "1.0"

[workspace.package]
version = "0.1.0"
edition = "2021"
]],
        ["crates/core/Cargo.toml"] = [[
[package]
name = "my-core"
version.workspace = true
edition.workspace = true
]],
        ["crates/utils/Cargo.toml"] = [[
[package]
name = "my-utils"
version = "0.2.0"
edition = "2021"
]],
        ["bin/cli/Cargo.toml"] = [[
[package]
name = "my-cli"
version.workspace = true
edition.workspace = true
]],
      })
    end)

    it("should detect Cargo workspaces correctly", function()
      local monorepo_type = core.detect_monorepo_type(cargo_workspace)
      assert.are.equal("cargo", monorepo_type)
    end)

    it("should enumerate Cargo workspace members", function()
      local packages = core.enumerate_packages(cargo_workspace)

      assert.is.table(packages)
      assert.are.equal(3, #packages)

      local crate_names = {}
      for _, pkg in ipairs(packages) do
        table.insert(crate_names, pkg.name)
      end

      assert.is_true(vim.tbl_contains(crate_names, "my-core"))
      assert.is_true(vim.tbl_contains(crate_names, "my-utils"))
      assert.is_true(vim.tbl_contains(crate_names, "my-cli"))
    end)

    it("should handle virtual Cargo workspace", function()
      local virtual_workspace = helpers.fs_create({
        ["Cargo.toml"] = [[
[workspace]
members = ["crates/*"]
resolver = "2"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
]],
        ["crates/web/Cargo.toml"] = [[
[package]
name = "web-server"
version = "0.1.0"
edition = "2021"
]],
        ["crates/db/Cargo.toml"] = [[
[package]
name = "database"
version = "0.1.0"
edition = "2021"
]],
      })

      local monorepo_type = core.detect_monorepo_type(virtual_workspace)
      assert.are.equal("cargo", monorepo_type)

      local packages = core.enumerate_packages(virtual_workspace)
      assert.is.table(packages)
      assert.are.equal(2, #packages)

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end
      assert.is_true(vim.tbl_contains(names, "web-server"))
      assert.is_true(vim.tbl_contains(names, "database"))
    end)

    it("should handle Cargo workspace with glob patterns", function()
      local glob_workspace = helpers.fs_create({
        ["Cargo.toml"] = [[
[workspace]
members = [
    "services/*",
    "libs/*",
    "tools/build",
]
]],
        ["services/auth/Cargo.toml"] = '[[package]]\nname = "auth-service"\nversion = "0.1.0"\nedition = "2021"',
        ["services/payment/Cargo.toml"] = '[[package]]\nname = "payment-service"\nversion = "0.1.0"\nedition = "2021"',
        ["libs/common/Cargo.toml"] = '[[package]]\nname = "common"\nversion = "0.1.0"\nedition = "2021"',
        ["tools/build/Cargo.toml"] = '[[package]]\nname = "build-tool"\nversion = "0.1.0"\nedition = "2021"',
      })

      local packages = core.enumerate_packages(glob_workspace)
      assert.is.table(packages)
      assert.are.equal(4, #packages)

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end
      assert.is_true(vim.tbl_contains(names, "auth-service"))
      assert.is_true(vim.tbl_contains(names, "common"))
      assert.is_true(vim.tbl_contains(names, "build-tool"))
    end)

    it("should handle Cargo workspace with exclude patterns", function()
      local exclude_workspace = helpers.fs_create({
        ["Cargo.toml"] = [[
[workspace]
members = ["crates/*"]
exclude = ["crates/experimental"]
]],
        ["crates/stable/Cargo.toml"] = '[[package]]\nname = "stable"\nversion = "1.0.0"\nedition = "2021"',
        ["crates/beta/Cargo.toml"] = '[[package]]\nname = "beta"\nversion = "0.5.0"\nedition = "2021"',
        ["crates/experimental/Cargo.toml"] = '[[package]]\nname = "experimental"\nversion = "0.1.0"\nedition = "2021"',
      })

      local packages = core.enumerate_packages(exclude_workspace)
      assert.is.table(packages)
      -- Note: Current implementation doesn't handle exclude, so this tests current behavior
      assert.are.equal(3, #packages) -- All packages found (exclude not implemented)
    end)

    it("should handle large Cargo workspaces with performance", function()
      local large_workspace = helpers.create_cargo_workspace(25)

      local start_time = vim.loop.hrtime()
      local packages = core.enumerate_packages(large_workspace)
      local end_time = vim.loop.hrtime()
      local duration_ms = (end_time - start_time) / 1000000

      assert.is.table(packages)
      assert.are.equal(25, #packages, "Should find all 25 crates in large Cargo workspace")

      -- Log performance for monitoring without hard assertions
      if duration_ms > 1000 then
        vim.notify(
          "[monava test] Cargo workspace enumeration slow: " .. duration_ms .. "ms",
          vim.log.levels.WARN
        )
      end
    end)

    it("should handle malformed Cargo.toml gracefully", function()
      local bad_workspace = helpers.fs_create({
        ["Cargo.toml"] = [[
[workspace]
members = [
    "good/crate1",
    "bad/crate2"
]],
        ["good/crate1/Cargo.toml"] = '[[package]]\nname = "good-crate"\nversion = "1.0.0"\nedition = "2021"',
        ["bad/crate2/Cargo.toml"] = '[[package]]\nname = "bad-crate"\nversion =',
      })

      local packages = core.enumerate_packages(bad_workspace)
      assert.is.table(packages)
      -- Should handle parsing errors gracefully
      assert.is_true(#packages >= 1, "Should find at least the good crate")

      local has_good = false
      for _, pkg in ipairs(packages) do
        if pkg.name == "good-crate" then
          has_good = true
        end
      end
      assert.is_true(has_good, "Should find the good crate")
    end)

    it("should handle Cargo workspaces with dependencies inheritance", function()
      local inherit_workspace = helpers.fs_create({
        ["Cargo.toml"] = [[
[workspace]
members = ["app", "lib"]

[workspace.dependencies]
serde = "1.0"
tokio = "1.0"

[workspace.package]
version = "0.1.0"
edition = "2021"
authors = ["Test Author <test@example.com>"]
]],
        ["app/Cargo.toml"] = [[
[package]
name = "my-app"
version.workspace = true
edition.workspace = true

[dependencies]
serde.workspace = true
my-lib = { path = "../lib" }
]],
        ["lib/Cargo.toml"] = [[
[package]
name = "my-lib"
version.workspace = true
edition.workspace = true

[dependencies]
tokio.workspace = true
]],
      })

      local packages = core.enumerate_packages(inherit_workspace, { include_metadata = true })
      assert.is.table(packages)
      assert.are.equal(2, #packages)

      local names = {}
      for _, pkg in ipairs(packages) do
        table.insert(names, pkg.name)
      end
      assert.is_true(vim.tbl_contains(names, "my-app"))
      assert.is_true(vim.tbl_contains(names, "my-lib"))
    end)
  end)
end)
