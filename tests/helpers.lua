local M = {}

-- Test file system root
local fs_root = vim.fn.stdpath("cache") .. "/monava-tests"

-- Normalize path relative to test fs root
function M.path(path)
  return fs_root .. "/" .. path
end

-- Create test files and directories
function M.fs_create(files)
  vim.fn.mkdir(fs_root, "p")

  for filepath, content in pairs(files) do
    local full_path = M.path(filepath)
    local dir = vim.fn.fnamemodify(full_path, ":h")

    -- Create directory if it doesn't exist
    if vim.fn.isdirectory(dir) == 0 then
      vim.fn.mkdir(dir, "p")
    end

    -- Create file with content
    if type(content) == "string" then
      local file = io.open(full_path, "w")
      if file then
        file:write(content)
        file:close()
      end
    end
  end

  return fs_root
end

-- Remove test directory
function M.fs_rm(dir)
  dir = dir or fs_root
  if vim.fn.isdirectory(dir) == 1 then
    vim.fn.delete(dir, "rf")
  end
end

-- Create a temporary directory for testing
function M.create_temp_dir()
  local temp_dir = vim.fn.tempname()
  vim.fn.mkdir(temp_dir, "p")
  return temp_dir
end

-- Create a test file with content
function M.create_test_file(dir, filename, content)
  local filepath = dir .. "/" .. filename
  local file_dir = vim.fn.fnamemodify(filepath, ":h")

  -- Create directory if it doesn't exist
  if vim.fn.isdirectory(file_dir) == 0 then
    vim.fn.mkdir(file_dir, "p")
  end

  local file = io.open(filepath, "w")
  if file then
    file:write(content or "")
    file:close()
  end
  return filepath
end

-- Assert that a table contains expected keys
function M.assert_has_keys(tbl, expected_keys, msg)
  msg = msg or "Table missing expected keys"
  for _, key in ipairs(expected_keys) do
    assert(tbl[key] ~= nil, msg .. ': missing key "' .. key .. '"')
  end
end

-- Assert that a function throws an error
function M.assert_error(func, expected_msg)
  local ok, err = pcall(func)
  assert(not ok, "Expected function to throw an error")
  if expected_msg then
    assert(err:find(expected_msg), "Error message doesn't contain expected text: " .. err)
  end
end

-- Mock vim.notify for testing
function M.mock_notify()
  local notifications = {}
  local original_notify = vim.notify

  vim.notify = function(msg, level, opts)
    table.insert(notifications, { msg = msg, level = level, opts = opts })
  end

  return {
    notifications = notifications,
    restore = function()
      vim.notify = original_notify
    end,
  }
end

-- Mock vim.ui.select for testing
function M.mock_ui_select()
  local selections = {}
  local original_select = vim.ui.select

  vim.ui.select = function(items, opts, on_choice)
    table.insert(selections, { items = items, opts = opts })
    -- Auto-select first item for testing
    if on_choice and items and #items > 0 then
      on_choice(items[1], 1)
    end
  end

  return {
    selections = selections,
    restore = function()
      vim.ui.select = original_select
    end,
  }
end

-- Wait for condition or timeout
function M.wait_for(condition, timeout)
  timeout = timeout or 1000
  local start_time = vim.loop.hrtime()

  while not condition() do
    local elapsed = (vim.loop.hrtime() - start_time) / 1000000
    if elapsed > timeout then
      error("Timeout waiting for condition")
    end
    vim.wait(10)
  end
end

-- Shared workspace creation utilities

-- Create NPM workspace with specified number of packages
function M.create_npm_workspace(package_count, options)
  options = options or {}
  local pattern = options.pattern or "packages/*"
  local lockfile_version = options.lockfile_version or 3

  local files = {
    ["package.json"] = string.format(
      '{"name": "test-npm-workspace", "workspaces": ["%s"], "private": true}',
      pattern
    ),
    ["package-lock.json"] = string.format('{"lockfileVersion": %d}', lockfile_version),
  }

  for i = 1, package_count do
    local pkg_path = string.format("packages/pkg%d/package.json", i)
    files[pkg_path] = string.format(
      '{"name": "@test/pkg%d", "version": "1.0.%d"%s}',
      i,
      i,
      options.include_metadata and ', "description": "Test package"' or ""
    )
  end

  return M.fs_create(files)
end

-- Create Yarn workspace with specified number of packages
function M.create_yarn_workspace(package_count, options)
  options = options or {}
  local pattern = options.pattern or "packages/*"
  local yarn_version = options.version or "v1"

  local files = {
    ["package.json"] = string.format(
      '{"name": "test-yarn-workspace", "workspaces": ["%s"], "private": true}',
      pattern
    ),
  }

  -- Different lock file formats for different Yarn versions
  if yarn_version == "v1" then
    files["yarn.lock"] = "# yarn lockfile v1\n\n"
  else
    files["yarn.lock"] =
      '# This file is generated by running "yarn install".\n__metadata:\n  version: 6\n'
    if options.yarnrc then
      files[".yarnrc.yml"] = "nodeLinker: pnp\nnmHoistingLimits: workspaces\n"
    end
  end

  for i = 1, package_count do
    local pkg_path = string.format("packages/pkg%d/package.json", i)
    files[pkg_path] = string.format('{"name": "@test/pkg%d", "version": "1.0.%d"}', i, i)
  end

  return M.fs_create(files)
end

-- Create Nx workspace with specified number of projects
function M.create_nx_workspace(project_count, options)
  options = options or {}
  local apps_count = math.ceil(project_count / 2)
  local libs_count = project_count - apps_count

  local files = {
    ["nx.json"] = string.format('{"plugins": ["@nx/js"], "parallel": %d}', options.parallel or 3),
  }

  -- Create apps
  for i = 1, apps_count do
    local project_file = string.format("apps/app%d/project.json", i)
    files[project_file] = string.format(
      '{"name": "app%d", "root": "apps/app%d", "sourceRoot": "apps/app%d/src"}',
      i,
      i,
      i
    )
  end

  -- Create libs (mix of project.json and package.json)
  for i = 1, libs_count do
    if i % 2 == 0 then
      -- Use package.json for some libs
      local pkg_file = string.format("libs/lib%d/package.json", i)
      files[pkg_file] = string.format('{"name": "@test/lib%d"}', i)
    else
      -- Use project.json for others
      local project_file = string.format("libs/lib%d/project.json", i)
      files[project_file] = string.format('{"name": "lib%d", "root": "libs/lib%d"}', i, i)
    end
  end

  return M.fs_create(files)
end

-- Create Cargo workspace with specified number of crates
function M.create_cargo_workspace(crate_count, options)
  options = options or {}
  local workspace_type = options.type or "virtual" -- "virtual" or "root"

  local members = {}
  for i = 1, crate_count do
    table.insert(members, string.format('"crates/crate%d"', i))
  end

  local cargo_toml = "[workspace]\nmembers = [\n    " .. table.concat(members, ",\n    ") .. "\n]\n"

  if workspace_type == "root" then
    cargo_toml = cargo_toml .. '\n[package]\nname = "workspace-root"\nversion = "0.1.0"\n'
  else
    cargo_toml = cargo_toml .. '\n[workspace.dependencies]\nserde = "1.0"\n'
  end

  local files = {
    ["Cargo.toml"] = cargo_toml,
  }

  -- Create individual crates
  for i = 1, crate_count do
    local crate_toml = string.format("crates/crate%d/Cargo.toml", i)
    files[crate_toml] =
      string.format('[package]\nname = "crate%d"\nversion = "0.1.0"\nedition = "2021"\n', i)
  end

  return M.fs_create(files)
end

-- Validate workspace packages
function M.validate_packages(packages, expected_count, expected_names)
  assert.is.table(packages, "Packages should be a table")

  if expected_count then
    assert.are.equal(expected_count, #packages, "Package count mismatch")
  end

  if expected_names then
    local found_names = {}
    for _, pkg in ipairs(packages) do
      table.insert(found_names, pkg.name)
    end

    for _, expected_name in ipairs(expected_names) do
      assert.is_true(
        vim.tbl_contains(found_names, expected_name),
        "Missing expected package: " .. expected_name
      )
    end
  end

  return packages
end

return M
